<program>           ::= <class>  | <struct> | <using> | <enum> | <interface>
<prefix_modifier>   ::= "static" | "abstract" | "override" | "virtual"
<class>             ::= <accessor>? <prefix_modifier>* "class" <ident> (":" <ident>* )? "{" (<method> | <property> | <member_variable> | <enum> | <constructor> | <destructor>)* "}"
<method>            ::= <accessor>? <prefix_modifier>* "method" <ident> "(" ("var" <ident> ":" <type>)* ")" ":" <type> <block>
<member_variable>   ::= <accessor>? <prefix_modifier>* "var" <ident> ":" <type> ("=" <expression>)? ";"


public class Program {
    public property Name ({ get; }, { private set; }): string;
    public property Age ({ get; }, { private set; }): int;

    public static readonly CONST_VAR: int = 1000;

    static method Main(var args: string[]): void
    {
        var a: int = 3;
        var program = new Program("hello", a);
        System.Std.WriteLine(program.Name.get());
        System.Std.WriteLine(program.Age.get());
    }

    public constructor(var name: string, var age: int)
    {
        this.Name.set(name);
        this.Age.set(age);
    }

    public method GetData(): (string, int)
    {
        return (this.Name.get(), this.Age.get());
    }
}

public interface IComparable
{
    method CompareTo(var other: IComparable): int;
}

public abstract class Base
{
    public abstract method Move(var distance: int): void;
}

public class Sub : Base, IComparable
{
    public override method Move(var distance: int): void
    {

    }

    public method CompareTo(var other: IComparable): int
    {
        return 0;
    }
}

pub class Program:
    pub prop Name(get; pri set;): string
    pub prop Age(get; pri set;): int

    pub stat val CONST_VAR: int = 1000

    stat met Main(var args: string[]): void:
        var a: int = 3, var name: string = "Kosuke"
        var program = new Program(name, a)
        System.Std.WriteLine(program.Name)
        System.Std.WriteLine(program.Age)

    pub const(name: string, age: int):
        Name = name
        Age = age

    pub met GetData(): (string, int):
        return (this.Name, this.Age)

pub inter IComparable:
    met CompareTo(other: IComparable): int

pub abst class Base:
    pub abst met Move(distance: int): void

pub class Sub(Base, IComparable):
    pub fin met Move(distance: int): void:
        pass

    pub met CompareTo(other: IComparable): int:
        return 0

pub class Generic<T>(IComparable):
    pass

<> ::= <defvar> ":" <linefeed>
# スペースかタブの数をカウント
# 所定のSyntaxを踏んだらブロックに入る
<stmt> ::= <expression> (<linefeed> | ";")
# 意味のあるLinefeedだけ読み込み意味のないものは読み飛ばす
# スペースの数が減少したらブロックの終わりを表すトークンを挿入してブロックを抜ける
# 最初はタブの数をスペース4つ分（タブ1つ）に設定しておく

// ==========================================

<program> ::= (
            <class>
            | <interface>
            | <enum>
            | <struct>
            | <using>
            )*
<class> ::= <accessor>? <prefix>* "class" <identifier> ("<" <identifier>* ">")? ("(" <identifier>* ")")? <class-block>
<class-block> ::= "{" (
                <method> 
                | <property> 
                | <member-variable>
                | <constructor>
                | <class>
                | <enum>
                )* "}"
<method> ::= <accessor>? <prefix>* "method" <identifier> "(" <variable-definition>* ")" ":" <identifier> <block>
<block> ::= "{" <statement>* "}"
<statement> ::= <expression> ";"
            | <block>
            | <return> ";"
            | <if>
            | <while>
            | <for>
<return> ::= "return" <expression>
<if> ::= "if" "(" <expression> ")" <statement> <else>?
<else> ::= "else" <statement>
<while> ::= "while" "(" <expression> ")" <statement>
<for> ::= "for" "(" <expression>? ";" <expression>? ";" <expression>? ")" <statement>
<expression> ::= <assign>
<assign> ::= <equality> ("=" <equality>)?
<equality> ::= <relational> ("==" <relational> | "!=" <relational>)?
<relational> ::= <addition> (
    "<" <addition>
    | "<=" <addition>
    | ">" <addition>
    | ">=" <addition>
)?
<addition> ::= <multiplication> ("+" <multiplication> | "-" <multiplication>)*
<multiplication> ::= <unary> ("*" <unary> | "/" <unary>)*
<unary> ::= ("+" | "-")? <primary>
<primary> ::= <numericliteral> 
            | <localvariable> 
            | "(" <expression> ")"
            | <method-call>
<method-call> ::= <identifier> "(" ")"
<numericliteral> ::= ("0" ~ "9")*
<localvariable> ::= <identifier>
<identifier> ::= ("a" ~ "z" | "A" ~ "Z" | "0" ~ "9" | "_")*

// ==========================================

<program> ::= <statement>*
<statement> ::= <expression> ";"
            | <block>
            | <return> ";"
            | <if>
            | <while>
            | <for>
<block> ::= "{" <statement>* "}"
<return> ::= "return" <expression>
<if> ::= "if" "(" <expression> ")" <statement> <else>?
<else> ::= "else" <statement>
<while> ::= "while" "(" <expression> ")" <statement>
<for> ::= "for" "(" <expression>? ";" <expression>? ";" <expression>? ")" <statement>
<expression> ::= <assign>
<assign> ::= <equality> ("=" <equality>)?
<equality> ::= <relational> ("==" <relational> | "!=" <relational>)?
<relational> ::= <addition> (
    "<" <addition>
    | "<=" <addition>
    | ">" <addition>
    | ">=" <addition>
)?
<addition> ::= <multiplication> ("+" <multiplication> | "-" <multiplication>)*
<multiplication> ::= <unary> ("*" <unary> | "/" <unary>)*
<unary> ::= ("+" | "-")? <primary>
<primary> ::= <numericliteral> 
            | <localvariable> 
            | "(" <expression> ")"
            | <method-call>
<method-call> ::= <identifier> "(" ")"
<numericliteral> ::= ("0" ~ "9")*
<localvariable> ::= <identifier>
<identifier> ::= ("a" ~ "z" | "A" ~ "Z" | "0" ~ "9" | "_")*